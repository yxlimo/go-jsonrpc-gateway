package gengateway

import (
	"bytes"
	"strings"
	"text/template"

	"github.com/golang/glog"

	"github.com/yxlimo/go-jsonrpc-gateway/internal/casing"
	"github.com/yxlimo/go-jsonrpc-gateway/internal/descriptor"
)

type param struct {
	*descriptor.File
	Imports []descriptor.GoPackage
}

type binding struct {
	Method   *descriptor.Method
	Registry *descriptor.Registry
}

type trailerParams struct {
	Services           []*descriptor.Service
	RegisterFuncSuffix string
}

func applyTemplate(p param, reg *descriptor.Registry) (string, error) {
	w := bytes.NewBuffer(nil)
	if err := headerTemplate.Execute(w, p); err != nil {
		glog.Errorf("executing header template: %v", err)
		return "", err
	}
	var targetServices []*descriptor.Service

	for _, msg := range p.Messages {
		msgName := casing.Camel(*msg.Name)
		msg.Name = &msgName
	}

	for _, svc := range p.Services {
		var methodWithBindingsSeen bool
		svcName := casing.Camel(*svc.Name)
		svc.Name = &svcName

		for _, meth := range svc.Methods {
			methodWithBindingsSeen = true
			glog.V(2).Infof("Processing %s.%s", svc.GetName(), meth.GetName())
			methName := casing.Camel(*meth.Name)
			meth.Name = &methName
			if err := handlerTemplate.Execute(w, binding{
				Method:   meth,
				Registry: reg,
			}); err != nil {
				glog.Errorf("executing handler template: %v", err)
				return "", err
			}
		}
		if methodWithBindingsSeen {
			targetServices = append(targetServices, svc)
		}
	}
	if len(targetServices) == 0 {
		return "", errNoTargetService
	}

	tp := trailerParams{
		Services:           targetServices,
		RegisterFuncSuffix: "JSONRPCHandler",
	}

	if err := trailerTemplate.Execute(w, tp); err != nil {
		glog.Errorf("executing trailer template: %v", err)
		return "", err
	}
	return w.String(), nil
}

var (
	headerTemplate = template.Must(template.New("header").Parse(`
// Code generated by protoc-gen-jsonrpc-gateway. DO NOT EDIT.
// source: {{.GetName}}

// Package {{.GoPkg.Name}} is a reverse proxy.

// It translates gRPC into JSON-RPC APIs.
package {{.GoPkg.Name}}
import (
	{{range $i := .Imports}}{{if $i.Standard}}{{$i | printf "%s\n"}}{{end}}{{end}}

	{{range $i := .Imports}}{{if not $i.Standard}}{{$i | printf "%s\n"}}{{end}}{{end}}
)

// Suppress "imported and not used" errors
var _ codes.Code
var _ io.Reader
var _ status.Status
var _ = runtime.String
var _ = metadata.Join
var _ = json.Marshal
var _ = jsonrpc.NewHTTPServerConn
`))

	handlerTemplate = template.Must(template.New("handler").Parse(`
{{if and (not .Method.GetServerStreaming) (not .Method.GetClientStreaming)}}
{{template "client-rpc-request-func" .}}
{{end}}
`))

	_ = template.Must(handlerTemplate.New("request-func-signature").Parse(strings.Replace(`
func request_{{.Method.Service.GetName}}_{{.Method.GetName}}_jsonrpc(ctx context.Context, marshaler runtime.Marshaler, client {{.Method.Service.InstanceName}}Client, raw json.RawMessage) (proto.Message, runtime.ServerMetadata, error)
`, "\n", "", -1)))

	_ = template.Must(handlerTemplate.New("client-rpc-request-func").Parse(`
{{template "request-func-signature" .}} {
	var protoReq {{.Method.RequestType.GoType .Method.Service.File.GoPkg.Path}}
	var metadata runtime.ServerMetadata
	if err := marshaler.NewDecoder(bytes.NewReader(raw)).Decode(&protoReq); err != nil && err != io.EOF  {
		return nil, metadata, status.Errorf(codes.InvalidArgument, "%v", err)
	}
	msg, err := client.{{.Method.GetName}}(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err
}`))

	trailerTemplate = template.Must(template.New("trailer").Parse(`
{{range $svc := .Services}}
// Register{{$svc.GetName}}{{$.RegisterFuncSuffix}}FromEndpoint is same as Register{{$svc.GetName}}{{$.RegisterFuncSuffix}} but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func Register{{$svc.GetName}}{{$.RegisterFuncSuffix}}FromEndpoint(ctx context.Context, mux *jsonrpc.ServeMux, endpoint string, opts []grpc.DialOption) (err error) {
	conn, err := grpc.Dial(endpoint, opts...)
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
			return
		}
		go func() {
			<-ctx.Done()
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
		}()
	}()

	return Register{{$svc.GetName}}{{$.RegisterFuncSuffix}}(ctx, mux, conn)
}

// Register{{$svc.GetName}}{{$.RegisterFuncSuffix}} registers the http handlers for service {{$svc.GetName}} to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func Register{{$svc.GetName}}{{$.RegisterFuncSuffix}}(ctx context.Context, mux *jsonrpc.ServeMux, conn *grpc.ClientConn) error {
	return Register{{$svc.GetName}}{{$.RegisterFuncSuffix}}Client(ctx, mux, {{$svc.ClientConstructorName}}(conn))
}

// Register{{$svc.GetName}}{{$.RegisterFuncSuffix}}Client registers the http handlers for service {{$svc.GetName}}
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "{{$svc.InstanceName}}Client".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "{{$svc.InstanceName}}Client"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "{{$svc.InstanceName}}Client" to call the correct interceptors.
func Register{{$svc.GetName}}{{$.RegisterFuncSuffix}}Client(ctx context.Context, mux *jsonrpc.ServeMux, client {{$svc.InstanceName}}Client) error {
	{{range $m := $svc.Methods}}
	{{if and (not $m.GetServerStreaming) (not $m.GetClientStreaming)}}
	mux.Register("{{$svc.GetName}}.{{$m.GetName}}", func(req *http.Request, marshaller runtime.Marshaler, rawBody json.RawMessage) (json.RawMessage, context.Context, error) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		var err error
		ctx, err = runtime.AnnotateContext(ctx, mux.RuntimeMux(), req, "/{{$svc.File.GetPackage}}.{{$svc.GetName}}/{{$m.GetName}}")
		if err != nil {
			return nil, ctx, err
		}
		resp, md, err := request_{{$svc.GetName}}_{{$m.GetName}}_jsonrpc(ctx, marshaller, client, rawBody)
		ctx = runtime.NewServerMetadataContext(ctx, md)
		if err != nil {
			return nil, ctx, err
		}
		rawResp, err := marshaller.Marshal(resp)
		if err != nil {
			return nil, ctx, err
		}
		return rawResp, ctx, nil

	})
	{{end}}
	{{end}}
	return nil
}

{{end}}`))
)
